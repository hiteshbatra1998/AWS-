WHAT IS OS ?
It act as itermediatory between computer hardware and its users. The hardware consists of memory, CPU, ALU, and I/O devices, peripheral device, and storage device. 
Purpose of an operating system is to provide an environment in which a user can execute programs in a convenient and efficient manner.
An operating system is a software that manages the computer hardware
An Operating System performs all the basic tasks like managing file,process, and memory. Thus operating system acts as manager of all the resources, i.e. resource manager.
It performs basic tasks such as recognizing input from the keyboard, keeping track of files and directories on the disk, sending output to the display screen and controlling peripheral devices.
controls the execution of application programs
A more common definition is that the operating system is the one program running at all times on the computer (usually called the kernel), with all else being application programs
Function of OS -> An operating system is concerned with the allocation of resources and services, such as memory, processors, devices, and information. The operating system correspondingly includes programs to manage these resources, such as a traffic controller, a scheduler, memory management module, I/O programs, and a file system.

Goals of Operating system – Operating system performs three functions:
Convenience: An OS makes a computer more convenient to use.
Efficiency: An OS allows the computer system resources to be used in an efficient manner.
Ability to Evolve: An OS should be constructed in such a way as to permit the effective development, testing and introduction of new system functions at the same time without interfering with service.

Abstract view of System :-
User interact with 3rd party applications installed on os -> Which interact with OS  -> Which interact with computer hardware

The Operating system must support the following tasks. The task are:
Provides the facilities to create, modification of programs and data files using an editor.
Access to the compiler for translating the user program from high level language to machine language.
Provide a loader program to move the compiled program code to the computer’s memory for execution.
Provide routines that handle the details of I/O programming.

Compiler – The language processor that reads the complete source program written in high level language as a whole in one go and translates it into an equivalent program in machine language is called as a Compiler. Ex C, C++ 
Assembler –The Assembler is used to translate the program written in Assembly language into machine code. The source program is a input of assembler that contains assembly language instructions. The output generated by assembler is the object code or machine code understandable by the computer.
Interpreter –The translation of single statement of source program into machine code is done by language processor and executes it immediately before moving on to the next line is called an interpreter. If there is an error in the statement, the interpreter terminates its translating process at that statement and displays an error message. 
             The interpreter moves on to the next line for execution only after removal of the error. An Interpreter directly executes instructions written in a programming or scripting language without previously converting them to an object code or machine code.Example: Perl, Python and Matlab.
             
TYPES OF OS :-
1) Batch os -> Copy
2) Multiprogramming -> Copy ( Not necessary to mention )
3) Time Sharing / Multitasking -> Each task is given some time to execute, so that all the tasks work smoothly. Each user gets time of CPU as they use single system. These systems are also known as Multitasking Systems. 
                                  The task can be from single user or from different users also. The time that each task gets to execute is called quantum. After this time interval is over OS switches over to next task.
                                  Multiprogramming with time sharing.
                                  From Copy too.
                                  eg - UNIX
4) Multiprocesing -> Multiple cpu. Can be symetric and asymetric ( Master Slave ) .
                     Copy
                     An asymmetric multiprocessing system is a multiprocessor computer system where not all of the multiple interconnected central processing units are treated equally. For example, a system might allow only one CPU to execute operating system code or might allow only one CPU to perform I/O operations
                      
5) Distributed OS -> Various autonomous interconnected computers communicate each other using a shared communication network.
                      Independent systems possess their own memory unit and CPU. These are referred as loosely coupled systems or distributed systems. These system’s processors differ in size and function. The major benefit of working with these types of operating system is that it is always possible 
                      that one user can access the files or software which are not actually present on his system but on some other system connected within this network i.e., remote access is enabled within the devices connected in that network.   
                      ADVANTAGE -> Failure of one will not affect the other network communication, as all systems are independent from each other
                                   Electronic mail increases the data exchange speed
                                    Since resources are being shared, computation is highly fast and durable
                                    Load on host computer reduces
                      DISADVANTAGE -> These types of systems are not readily available as they are very expensive
                                       Failure of the main network will stop the entire communication
                      eg - LOCUS OS.
6) *It is architectute * Network / Client Server -> These systems run on a server and provide the capability to manage data, users, groups, security, applications, and other networking functions. These type of operating systems allow shared access of files, printers, security, applications, and other networking functions over a small private network. 
                              One more important aspect of Network Operating Systems is that all the users are well aware of the underlying configuration, of all other users within the network, their individual connections etc. and that’s why these computers are popularly known as tightly coupled systems.
                              Advantages of Network Operating System:
                              Highly stable centralized servers
                              Security concerns are handled through servers
                               New technologies and hardware up-gradation are easily integrated to the system
                               Disadvantages of Network Operating System:
                               Servers are costly
                               User has to depend on central location for most operations
                               Maintenance and updates are required regularly
                               EG Microsoft Windows Server 2003, Microsoft Windows Server 2008, UNIX, Linux
                              
 7) Real Time OS -> These types of OSs serves the real-time systems. The time interval required to process and respond to inputs is very small. This time interval is called response time.
                    Real-time systems are used when there are time requirements are very strict like missile systems, air traffic control systems, robots etc.
                    Two types of Real-Time Operating System which are as follows:
                    Hard Real-Time Systems:
                        These OSs are meant for the applications where time constraints are very strict and even the shortest possible delay is not acceptable. These systems are built for saving life like automatic parachutes or air bags which are required to be readily available in case of any accident. 
                        memory is almost never found in these systems.
                    Soft Real-Time Systems:
                         These OSs are for applications where for time-constraint is less strict.
                    Advantages of RTOS:
                      Maximum Consumption: Maximum utilization of devices and system,thus more output from all the resources
                      Task Shifting: Time assigned for shifting tasks in these systems are very less. For example in older systems it takes about 10 micro seconds in shifting one task to another and in latest systems it takes 3 micro seconds.
                      Focus on Application: Focus on running applications and less importance to applications which are in queue.
                    Disadvantages of RTOS:
                      Limited Tasks: Very few tasks run at the same time and their concentration is very less on few applications to avoid errors.
                      Use heavy system resources: Sometimes the system resources are not so good and they are expensive as well.
                      Complex Algorithms: The algorithms are very complex and difficult for the designer to write on.
                    Eg used in aircraft , satellite , Scientific experiments , air traffic control systems
 
8) Parallel System , Personal System -> Copy. 

Read This.
https://www.geeksforgeeks.org/difference-between-multitasking-multithreading-and-multiprocessing/      

Types Of Memory in OS -> There are 4 types of memory - Primary/Main , Secondary , Cache ,Register
                        Main memory (RAM and ROM) and Secondary memory(hard drive,CD,etc.). 
                        Random Access Memory (RAM) is primary-volatile memory and Read Only Memory (ROM) is primary-non-volatile memory.
                        RAM is devided into SRAM and DRAM 
                        ROM is devided into PROM EPROM EEPROM
                        
                        Random Access Memory (RAM) –
                          It is also called as read write memory or the main memory or the primary memory.
                          The programs and data that the CPU requires during execution of a program are stored in this memory.
                          It is a volatile memory as the data loses when the power is turned off.
                        Read Only Memory (ROM) –
                            Stores crucial information essential to operate the system, like the program essential to boot the computer.
                            It is not volatile.
                            Always retains its data.
                            Used in embedded systems or where the programming needs no change.
                            Used in calculators and peripheral devices.
                            
( 1 byte = 8 bit , 1024 byte = 1KB  , 1024 KB = 1 MB , 1024 MB = 1GB , 1GB =  1024 PB petabyte)
 
Difference between 32-bit and 64-bit operating systems
In computing, there exist two type processor i.e., 32-bit and 64-bit. This type of processor tells us how much memory a processor can have access from a CPU register.
A 32-bit system can access 2^32 memory addresses, i.e 4 GB of RAM or physical memory ideally, it can access more than 4 GB of RAM also. The actual limit is often less around 3.5 GB since part of the register is used to store other temporary values besides memory addresses 
A 64-bit system can access 2^64 memory addresses, i.e actually 18-Quintillion bytes of RAM. In short, any amount of memory greater than 4 GB can be easily handled by it.
major difference between 32-bit processors and 64-bit processors is the number of calculations per second they can perform, which affects the speed at which they can complete tasks. 
64-bit processors can come in dual-core, quad-core, six-core, and eight-core versions for home computing. Multiple cores allow for an increased number of calculations per second that can be performed, which can increase the processing power and help make a computer run faster
Cores state the number of process stay at a time in primary/main memory. Dual core - 2 process at a time.
A computer with a 64-bit processor can have a 64-bit or 32-bit version of an operating system installed. However, with a 32-bit operating system, the 64-bit processor would not run at its full capability.  
 
Memory Partition
Continous & Non continous.
Continous -> Copy
Non Contigous -> Paging & Segmentation
Physical address & Logical address -> https://www.youtube.com/watch?v=CmTMr_x3NwY
Need of logical/
address -> Security - so that user cant access the memory directlty.
Logical Address Space is the set of all logical addresses generated by CPU for a program whereas the set of all physical address mapped to corresponding logical addresses is called Physical Address Space
The logical address is virtual address as it does not exist physically, therefore, it is also known as Virtual Address
Swapping -> The process of swapping process from main memory to secondary memory(hard disk)

PAGING -
The memory management unit converts logical address into physical address with the help of technique called paging.
Size of physical address is dependent on main memory.
Physical memory / Main memory / RAM -> Devided into equal size called frames. 
Process is devided into equal parts called pages -> https://www.youtube.com/watch?v=6c-mOFZwP_8&list=PLxCzCOWd7aiGz9donHRrE9I3Mwn6XdP8p&index=51 ( Must Watch if dont remember exact concept which is not possible )
Virtual Memory -> Virtual memory is an area of a computer system's secondary memory storage space (such as a hard disk or solid state drive) which acts as if it were a part of the system's RAM or primary memory. 
USed To run process whose size is greater than main mempry.  https://www.youtube.com/watch?v=o2_iCzS9-ZQ&list=PL0O0wvOlQhfK-DC533eojLLMf8JGg8XbI&index=22 (Demand Paging)
Virtual Memory never exist physically.It contains all the process of whcih some pages are in main memory.
Internal fragmentation is still there.
When paging is done it does not check the interlinking of pages. High interlinking of pages can result in less time for response thus segmentation is there. 

Segmentation -
It devide process so that dependency of each part is least. Like a c program we can devide it by various functions. And It does not have internal fragmentation.
It devide program into segments of unequal size.
Segment table have segment adress of a particular segment located in main memory for a process and its size.
CPU generate logical address having segment name and segment offset(size cpu want to read). The segment offset should be <= the limit of segment in segment table otheriwse trap would be generated.
Space consumption is less in segmentation as compared to paging. No internal fragmentation but there is external fragmentation.
https://www.youtube.com/watch?v=dz9Tk6KCMlQ
There is concept of demand segmentation also. All segments of a process are not available in main memory they only come from secondary when there is demand of that segment.


Thrashing -> Whith the increase in degree of multiprogramming , CPU utilization increases but with more increase it starts decreasing due to more page faults. Graph in copy.
Overlay -> It is used to run program larger than main memory in embedded systems. Just like virtual memory in todays os.

Page Replacement Algorithms
In an operating system that uses paging for memory management, a page replacement algorithm is needed to decide which page needs to be replaced when new page comes in
1)FIFO ( you know)  
Belady’s anomaly (For FIFO) – Belady’s anomaly proves that it is possible to have more page faults when increasing the number of page frames while using the First in First Out (FIFO) page replacement algorithm.  
For example, if we consider reference string 3, 2, 1, 0, 3, 2, 4, 3, 2, 1, 0, 4 and 3 slots, we get 9 total page faults, but if we increase slots to 4, we get 10 page faults.
2) Optimal Page Replacement
In this algorithm, pages are replaced which would not be used for the longest duration of time in the future.
3) Least Resently Used 
In this algorithm page will be replaced which is least recently used. Initially when frames are empty then to fill them page faults occur.


-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
UNIT 2

PROCESS -> A program in execution is called process.
           It can be divided into four sections ─ stack, heap, text and data
           Stack contains all the temporary data like functions , local variable , return address (return address refers to address of the code segment or instruction whose function call has created that stack) .  
            Heap is the memory allocated dynamically to the process.
           Text contain value of program counter and content of processors register.
           Data contains global and static variables.

Process State Diagram -> https://www.youtube.com/watch?v=-ddfZ0atNAU&list=PL0O0wvOlQhfIo2r0ebA6f_IcC5TzT2Bwr&index=2       & copy.

Process Management -> Moving of program from secondary memory to main memory and wait in ready queue to be executed.
Process control block (PCB) - A process can have : id (PID) , state , stack pointer(address of program counter about whoch instruction is currently running) , scheduling algorithm , priority etc. 
Interrupt & Interprocess communication -> Copy 
Difference between short term scheduler & dispatcher -> copy
Context swtiching -> The process of saving the context of one process and loading the context of another process is known as Context Switching.

Inter process communication (IPC) is used for exchanging data between multiple threads in one or more processes or programs.
It can be done using shared memory & message passing.
Shared memory -needs some variable to get info about the shared resourse and its completely dependent on programmer how they want to implement it.
               Ex - Producer consumer problem.One produces item other consume it. And we can write code accordingly. 
Message PAssing -> We can send message after establishing connection , no need to establish again if it is already there.
                   Message can be of fixed size or variable size.
                   It includes header and message. Header contain message source , destination , message type , length
                   Message passing through commnunication link
                          A link can have some capacity which specify the number of process that can stay in that link for which each link has a queue associated with it which can be of 
                          zero capacity , bound capacity & unbound capacity. In zero capacity sender waits until reciever receives the message whereas is non zero capacity the process dont know if message is delivered or not.
                          For this sender must communicate explicitly to reciever.
                          Communication link can be direct and specify the address like print command it is hard to determine sender. Indirect link can be mailbox where messages are stored in queue.
                   Message Passing through exchanging the message
                    ASK SAHIL ( https://www.geeksforgeeks.org/inter-process-communication-ipc/ )
     
     
 THREADS 
 A process can contain multiple threads , we devide process into threads to achieve parallelism and it provides illusion that multiple threds are ruuning at a time(mutithreading).
 Thread is a light weight process. They have stack area  , register set and program counter.
 Simlarity between thread and process - Both process and threads can produce children  , One process or thread is active at a time.
 Differences between Threads and Processes – Threads are not independent, processes are. Threads are designed to assist each other, processes may or may not do it. threads within the same process run in a shared memory space, while processes run in separate memory spaces.
 Advantage of thread over process
      1) Faster context swicthing between threads and thus faster execution as we can do process multi threads on multi process.
      2) Responsiveness-> output of particular thread can be displayed immediately.
      3) Communication is faster in threads.
      4) Threads share resources like code , memory ( but each thread has its own stack ,  program counter and register )
      
      There are 2 type of threads - user level and kernel level.
      User level thread -> OS doesnt recognize this, it is implemented on user level, can be implemented of os which doesnt support multithreading. Implementation is easy and context swticthing is faster . Eg Java thread
      Kernel Level thread -> Implemented on OS level , Implementation is complicated & have more context swtiching time. Kernel level itself have a master thread table.KErnel also maintains a process table to keep record of process. Eg Solaris (Unix OS)
      
Process based multitasking -> Listing to musi and using word.
Thread based multitasking -> In ms word we can type , delete ,edit etc. Or through listning music we can change the track or increase decrease the volume

Thread Lifecycle -> copy.
Multi threading model (only comes in picture when os support both user level as well as kernel level thread) (https://www.geeksforgeeks.org/multi-threading-models-in-process-management/)
1) Many to Many -> Multiple user threads combines to give multiple kernel thread. If one user thread is blocked we caan use other user thread and systme doesnt get block.
2) Many to one -> Multiple user threads combines to give one kernel thread. If one user thread is blocked system get blocked
3) one to one -> One user threads give one kernel thread. Problem is that we need more kernel thread.

Process Synchrnization 
When two process are cooperative they need to be synchronozed so as to maintain consistency.
Race condition occur when two process manipulates a resource in different way and try to proove that the value of that variable/resource is what they have calculated.
Critical section -> It is a section in which oly one process can enter at a time. It includes all the shared memory . All the shared memory betwen process are to be manipulated in critical section.
While entering in critical section a process needs to check whether there is no other process in critical section.

Any solution to critical section problem must include -
1) Mutual exclusion - one porcess at a time in critical section.
2) Progress -> The process which are not in remainder section can enter in critical section if it is empty and that descion cant be postpooned indefinitely.  Like if critical section is empty and p1 wants ti enter but p2 is stopping it due to some code in entry section thus no progress would be there we cn solve this by allowing those process which or not in remainder section.
3) Bound waiting -> A limit must be maintained that how many times a process can enter in critical section after it has requsted permission to enter and before entering in critical sectin.
Solution must not be restricted to any particular specification of os like if a solution only run on 32 bit and not n 64 then it is not a solution.

Software solution to critical sectin problem 
Petersons solution -> In this there are two variable used - bool flag[i] initialized to false( to check if critical section is empty or not ) & int turn (to check which process want to enter).
                      Suppose there are two process i & j then code according to peterson solution is :
                      do{
                           bool flag[i] = true; 
                           int turn =j;
                           while( turn==j and flag[j] ) ;
                           *Enter scritical section and comes out of it*
                           flag[i] = false;
                           *Remainder section*
                      }while(true)
                      It follows all the three conditions
                      disadvantage -> Only for two process we can use this.
                      (https://www.youtube.com/watch?v=XAsAAJSotA4&t=451s)
                     
 Hardware solution to critical section 
 Test And Set -> We have shared a variable which act as a lock. if its value is 0 means unlock and 1 means lock.
                  It has preserves both mutual exclusion and progress but not bound waiting.


Semaphoers -> copy and https://www.youtube.com/watch?v=eoGkJWgxurQ&list=PL0O0wvOlQhfIo2r0ebA6f_IcC5TzT2Bwr&index=21

mutex , dining philosopher 

-------------------------------------------------------------------------------------------------------------------------------------------------------------
Unit 3
deadlock 
systme model ( 3 step severy process fllow not imp)
Deadlock occus if these 4 condition occur simultaneously
1) Mutua exclusion -> ne resource can be used by one process at a time
2)No preemption -> Resource cannot be released until process is completed
3) Hold and wait -> A process is holding one resource and waiting for another resource.
4) Circular waiting->Set of Process are waiting in circular fashion 

read from copy
Startvation -> Waiting time is so long but not infinite. 


deadlock handeling techniques - prevention , avoidance (bankers) , detection (bankers , resource allocation graph) , recovery  ]- read from copy

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



                          
